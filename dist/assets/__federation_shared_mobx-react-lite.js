import {importShared} from './__federation_fn_import.js';
const {makeObservable:E,configure:A,getDependencyTree:k,Reaction:h,observable:b,_allowStateChangesInsideComputed:L} = await importShared('mobx');
import{r as s,a as p}from"./index-835a4768.js";import{r as $}from"./index-ebdbfe2f.js";if(!s.useState)throw new Error("mobx-react-lite requires React with Hooks support");if(!E)throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");function I(e){e()}function M(e){e||(e=I),A({reactionScheduler:e})}var te=function(){return!0};function j(e){return k(e)}var g=typeof FinalizationRegistry>"u"?void 0:FinalizationRegistry;function B(e){var r={reaction:e,mounted:!1,changedBeforeMount:!1,cleanAt:Date.now()+z};return r}var z=1e4,D=1e4;function N(e){var r=new Map,t=1,i=new e(function(u){var o=r.get(u);o&&(o.reaction.dispose(),r.delete(u))});return{addReactionToTrack:function(n,u,o){var a=t++;return i.register(o,a,n),n.current=B(u),n.current.finalizationRegistryCleanupToken=a,r.set(a,n.current),n.current},recordReactionAsCommitted:function(n){i.unregister(n),n.current&&n.current.finalizationRegistryCleanupToken&&r.delete(n.current.finalizationRegistryCleanupToken)},forceCleanupTimerToRunNowForTests:function(){},resetCleanupScheduleForTests:function(){}}}var U=globalThis&&globalThis.__values||function(e){var r=typeof Symbol=="function"&&Symbol.iterator,t=r&&e[r],i=0;if(t)return t.call(e);if(e&&typeof e.length=="number")return{next:function(){return e&&i>=e.length&&(e=void 0),{value:e&&e[i++],done:!e}}};throw new TypeError(r?"Object is not iterable.":"Symbol.iterator is not defined.")};function P(){var e=new Set,r;function t(){r&&(clearTimeout(r),a())}function i(){var c,l;if(e.size>0){try{for(var f=U(e),d=f.next();!d.done;d=f.next()){var v=d.value,y=v.current;y&&(y.reaction.dispose(),v.current=null)}}catch(x){c={error:x}}finally{try{d&&!d.done&&(l=f.return)&&l.call(f)}finally{if(c)throw c.error}}e.clear()}r&&(clearTimeout(r),r=void 0)}function n(){r===void 0&&(r=setTimeout(a,D))}function u(c){e.add(c),n()}function o(c){e.delete(c)}function a(){r=void 0;var c=Date.now();e.forEach(function(l){var f=l.current;f&&c>=f.cleanAt&&(f.reaction.dispose(),l.current=null,e.delete(l))}),e.size>0&&n()}return{addReactionToTrack:function(c,l,f){return c.current=B(l),u(c),c.current},recordReactionAsCommitted:o,forceCleanupTimerToRunNowForTests:t,resetCleanupScheduleForTests:i}}var m=g?N(g):P(),q=m.addReactionToTrack,H=m.recordReactionAsCommitted,ne=m.resetCleanupScheduleForTests,F=!1;function V(e){F=e}function C(){return F}var w=globalThis&&globalThis.__read||function(e,r){var t=typeof Symbol=="function"&&e[Symbol.iterator];if(!t)return e;var i=t.call(e),n,u=[],o;try{for(;(r===void 0||r-- >0)&&!(n=i.next()).done;)u.push(n.value)}catch(a){o={error:a}}finally{try{n&&!n.done&&(t=i.return)&&t.call(i)}finally{if(o)throw o.error}}return u};function R(e){return"observer".concat(e)}var K=function(){function e(){}return e}();function Y(){return new K}function T(e,r){if(r===void 0&&(r="observed"),C())return e();var t=w(p.useState(Y),1),i=t[0],n=w(p.useState(),2),u=n[1],o=function(){return u([])},a=p.useRef(null);if(!a.current)var c=new h(R(r),function(){l.mounted?o():l.changedBeforeMount=!0}),l=q(a,c,i);var f=a.current.reaction;p.useDebugValue(f,j),p.useEffect(function(){return H(a),a.current?(a.current.mounted=!0,a.current.changedBeforeMount&&(a.current.changedBeforeMount=!1,o())):(a.current={reaction:new h(R(r),function(){o()}),mounted:!0,changedBeforeMount:!1,cleanAt:1/0},o()),function(){a.current.reaction.dispose(),a.current=null}},[]);var d,v;if(f.track(function(){try{d=e()}catch(y){v=y}}),v)throw v;return d}var _=typeof Symbol=="function"&&Symbol.for,S=_?Symbol.for("react.forward_ref"):typeof s.forwardRef=="function"&&s.forwardRef(function(e){return null}).$$typeof,O=_?Symbol.for("react.memo"):typeof s.memo=="function"&&s.memo(function(e){return null}).$$typeof;function oe(e,r){var t;if(O&&e.$$typeof===O)throw new Error("[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.");if(C())return e;var i=(t=r?.forwardRef)!==null&&t!==void 0?t:!1,n=e,u=e.displayName||e.name;if(S&&e.$$typeof===S&&(i=!0,n=e.render,typeof n!="function"))throw new Error("[mobx-react-lite] `render` property of ForwardRef was not a function");var o=function(a,c){return T(function(){return n(a,c)},u)};return u!==""&&(o.displayName=u),e.contextTypes&&(o.contextTypes=e.contextTypes),i&&(o=s.forwardRef(o)),o=s.memo(o),J(e,o),o}var G={$$typeof:!0,render:!0,compare:!0,type:!0,displayName:!0};function J(e,r){Object.keys(e).forEach(function(t){G[t]||Object.defineProperty(r,t,Object.getOwnPropertyDescriptor(e,t))})}function Q(e){var r=e.children,t=e.render,i=r||t;return typeof i!="function"?null:T(i)}Q.displayName="Observer";function ae(e,r){return s.useState(function(){return b(e(),r,{autoBind:!0})})[0]}var W=globalThis&&globalThis.__read||function(e,r){var t=typeof Symbol=="function"&&e[Symbol.iterator];if(!t)return e;var i=t.call(e),n,u=[],o;try{for(;(r===void 0||r-- >0)&&!(n=i.next()).done;)u.push(n.value)}catch(a){o={error:a}}finally{try{n&&!n.done&&(t=i.return)&&t.call(i)}finally{if(o)throw o.error}}return u};function X(e){var r=W(s.useState(function(){return b(e,{},{deep:!1})}),1),t=r[0];return L(function(){Object.assign(t,e)}),t}function ie(e,r){var t=r&&X(r);return s.useState(function(){return b(e(t),void 0,{autoBind:!0})})[0]}M($.unstable_batchedUpdates);function ue(e,r){return r===void 0&&(r="observed"),T(e,r)}function ce(e){V(e)}export{Q as Observer,ne as clearTimers,V as enableStaticRendering,te as isObserverBatched,C as isUsingStaticRendering,oe as observer,M as observerBatching,X as useAsObservableSource,ae as useLocalObservable,ie as useLocalStore,ue as useObserver,ce as useStaticRendering};
